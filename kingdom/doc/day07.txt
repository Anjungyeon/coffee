# day07

Object 클래스
==>	자바로 만들어진 클래스들의 최상위 super 클래스의 역할을 하는 클래스이다.
	따라서 자바로 만들어진 모든 클래스는 
	Object가 제공하는 모든 멤버(변수, 함수)를 자동적으로 사용할 수 있다.
	
	참고 ]
		이렇게 최상위 클래스를 만들어 놓은 이유??
		계층추적을 원활하게 하도록 하기 위한 조치....
		즉, 각각의 클래스의 족보를 정확하게 따질 수 있도록 하기 위해서...
		
	참고 ]
		자바로 만든 모든 클래스는 반드시 상위 클래스를 가지고 있다.
		우리가 지금까지 만든 클래스들도 상위 클래스를 가지고 있다.
		만약 강제로 상위 클래스를 지정하지 않으면(extends Xxxxx)
		암묵적으로 Object 클래스를 상속받아서 만들어진다.
		
**
instancof
==> 특정 클래스를 new 시키면 주소만들어지는데
	이 주소가 어떤 클래스 소속의 주소인지를 알려주는 연산자이다.
	연산의 결과는 
		true | false
	반환된다.
	
	형식 ] 
		
		주소	instanceof	클래스이름
		
	의미 ]
		주소가 가리키고 있는 곳의 내용이
		지정한 클래스 소속인지를 물어보는 것이다.
		
	참고 ]
		소속이라는 개념은 is a 관계를 따져주는 것이다.
		상속 관계를 따지는 개념이 소속이라는 개념이다.
		
=======================================================================================================
속성2
	
	final 속성
		
		1. final 클래스(상속과 관계)
			==> final 속성이 붙은 클래스는 상속이 불가능한 클래스임을 밝히는 속성이다.
				기능을 추가 또는 변경하지 말고
				현재 기능 그대로만 사용하세요. 라는 의미...
			
		2. final 함수(오버라이드 관계)
			==> 이 함수는 오버라이드가 불가능한 함수 라는 의미
				따라서 이 함수는 중요한 함수이므로
				함부로 기능을 바꾸지 말고 현재 기능을 그대로 사용하세요.
		
		3. final 변수
			==> 이 변수는 값을 수정할 수 없는 변수이다.
				따라서 현재 값을 유지해야만 하는 변수
				
=======================================================================================================
package와 import
	
	package란?
	==> 한마디로 말하면 자바 프로그램(소스)가 들어있는 폴더를 
		자바에서 부르는 용어
		
		자바는 오픈소스이다.
		모든 사람이 자신이 만든 프로그램을 다른 사람에게 배포할 수 있고
		그것을 모든 사람이 이용할 수 있는 프로그램이다.
		
		이러다보니 문제점이 발생했다.
			클래스이름이 충돌이 생길 수 있다.
		이런 문제를 해결하기 위해서 만들어 놓은 하가지 방책이 
		패키지 이다.
		
		즉, 소스코드를 만드는 사람이 그 프로그램이 포함되는 폴더이름까지 정해서
		프로그램을 만들도록 하는 것.
		
		결론적으로 자바 프로그램을 만들때는 반드시 이 프로그램이
		어떤 폴더에 저장되는지를 알려주도록 해 놓았다.
		
		명령 ]
			package		폴더이름;
			
	참고 ]
		패키지 이름을 만든 권장 사항
			자신이 사용하는 도메인을 거꾸로 쓴 후 다음에 다시 폴더이름을 붙여라.
			
		예 ]
			banjang.cnu.ac.kr
			
			==> 패키지이름
					kr.ac.cnu.banjang.day01;
					
======================================================================================

import 란?
	==> 자신이 사용할 클래스가 어느 폴더(패키지)에 있는
		클래스를 사용하는 지를 밝혀주기 위한 명령.
		
		예 ]
			내가 
				Test.class
				Sample 폴더에 저장되어있다.
				
				Test.class
				day08 폴더에 저장되이있다.
				
			==> Sample 패키지의 Test 클래스를 사용해야 한다면
				
				import Sample.Test;
				
		형식 1]
			
			import 패키지경로.클래스이름;
			==> 지정한 클래스만 사용할 준비를 한다.
			
		형식 2 ]
			
			import 패키지경로.*;
			==> 패키지 바로 하위에 있는 클래스만 사용할 준비
			
		참고 ]
			우선순위는 1번형식이 우선한다.
			
			
	참고 ]
		import 하지 않아도 
		명시적으로 클래스 이름 앞에 패키지 이름을 붙여서 사용할 수도 있다.
		
		형식 ]
			
			패키지경로.사용할클래스이름 변수이름 = new 패키지경로.사용할클래스이름();
		
	참고 ]
		
		유일하게 java.lang 패키지는 import 하지 않아도 사용할 수 있다.
		
		왜?
			JVM이 기본적으로 찾아보는 패키지이기 때문에...
			
	참고 ]
		* 를 사용해서 import 하는 경우 
		하위 패키지 소속의 클래스는 사용할 수 없다.
		
		예 ]
			import java.awt.*;
			import java.awt.event.*;
			
======================================================================================================

static import
==> static 멤버는 원칙적으로 
		클래스이름.멤버 
	의 형식으로 사용해야 한다.
	
	이때 static 멤버 앞에 사용하는 클래스이름 조차도 생략할 수 있다.
	==> 이처럼 static 사용할 때 
		클래스 이름조차도 생략하는 방법이 static import 이다.
		
	형식 ]
		
		import static	패키지경로.클래스이름.*;
		
======================================================================================================

추상클래스
==> 추상 함수를 0개이상 가지고 있는 클래스
	즉, 추상 함수가 있으면 반드시 추상클래스가 되고
	없어도 추상클래스가 될수 있다.
	
	추상함수
	==> 함수의 몸체가(실행내용 : {} ) 없는 함수를 말한다.
		즉, 기능이 없는 함수를 말한다.
		
		형식 ]
			
			[접근지정자]	abstract 	반환값타입	함수이름(매개변수리스트);
			
		예 ]
			public abstract void abc(String name);
			
			
	추상클래스 만드는 방법
		
		형식 ]
			
			[접근지정자]	abstract	class	클래스이름 {
				변수;
				일반함수;
				추상함수;
			}
			
	추상클래스 사용하는 방법
		==> 추상클래스는 스스로 new 시킬 수 없다.
			왜냐하면 그 안에는 기능이 없는 함수가 존재할 수 있기 때문에...
			
			1. 다른 클래스에 상속을 해준후
				추상 함수의 기능을 만들어주고(오버라이드 해서)
				하위 클래스를 new 시켜서 사용하면 된다.
				==> 실제 이렇게 사용하는 방법은 10% 미만...
				
			2. 멤버함수중 속성이 static이면서 반환값이 자기자신인 함수를 호출해서 
				객체 를 만들어서 사용하면 된다.
				
				예 ]
					
					Calendar 클래스의 경우
						
					Calendar cal = new Calendar();	==> 절대로 안된다.
					
					Calendar cal = Calendar.getInstance();
					
					
	참고 ]
		추상 클래스가 아님에도 불구하고
		new 를 못시키는 클래스가 있다.
		이 경우는 생성자 함수가 없는 것이 아니고
		private 으로 접근지정자를 지정해서 감춰둔 경우이다.
		
		이런 클래스 역시 
			속성이 static 이면서 반환값이 자기자신인 함수를 찾아서 사용하면 된다.
			
		이런 함수가 없는 경우는 관련 클래스에 이 클래스타입의 데이터를 반환해주는 함수가
		존재할 것이므로 그 함수를 사용하면 된다.

======================================================================================================

인터페이스( Interface )
==> 클래스의 한 종류이긴 하지만 약간 그 형태나 의미가 
	지금까지 배웠던 클래스하고는 다른 특수한 클래스의 일종이다.
	
	1. 최상위 클래스가 Object가 아니다.
		==> 인터페이스는 다른 클래스를 상속 받아서 만들어진 클래스가 아니다.
		
	2. 이 안에는 100% 추상함수가 존재해야 한다.
		==> 절대로 일반함수가 존재하면 안된다.
			기능을 가진 함수가 존해하면 안된다.
			
		참고 ]
			interface 내의 추상함수
			==> abstract를 선언하지 않아도 자동적으로 몸체가 없는 추상함수가 된다.
			
			==> 인터페이스 내에서 함수를 정의 할 때
				접근 지정자와 속성을 지정하지 않으면
				자동적으로
					public abstract 
				로 만들어진다.
				
				예 ]
					
					public interface Sample {
						void abc();
						==>
							public abstract void abc();
					}
					
	3. 인터페이스는 다른 클래스에 상속해줄 수 있는데
		다중상속이 가능하다.
		
	4. 변수는 가질 수 있다.
		이때 이 변수는 자동적으로 
			public static final 변수가 된다.
			
	5. 인터페이스 소속 함수는 자동적으로 public 함수가 된다.


	만드는 방법 ]
		
		[접근지정자] 	interface	인터페이스이름 	{
			변수;	==> 자동적으로 public static final 변수
			함수;	==> 자동적으로 public abstract 함수가 된다.
		}
		
		
	인터페이스를 만든 이유
		==> 가끔은 JVM에 의해서 자동 호출되어야 하는 함수가 필요하다.
			
			따라서 함수의 존재는 필요하다.
			하지만 가끔은 이 함수가 해야할 내용을 정하지 못하는(개발자가 정해야 하는)
			경우가 있다.
			
			따라서 기능은 개발자의 몫으로 남긴 것이다.
			
		참고 ]
			자바에서 이벤트를 처리하는 순서
			
			1. 사용자가 버튼을 클랙하면 이벤트가 발생한다.
				이 이벤트는 운영체제가 인지를 하게 된다.
			2. 운영체제는 자신이 인지한 이벤트가 발생한 프로그램을 구분하여
				그 프로그램을 담당하는 플렛폼(JVM)에게 통보를 한다.	
			3.  JVM은 통보받은 이벤트의 정보를 분석하여
				그 정보에 맞는 함수를 호출하여 이벤트를 처리한다.
				==> 해당 정보에 합당한 함수를 호출한다는데 의미가 있다.
					결국 함수가 존재해야 한다.
				==> 이벤트가 발생하면 무엇을 처리할지는 JVM 이 결정하는 것이 아니다.
				
				
				
	인터페이스 사용하기
		
		1. 인터페이스는 스스로 new 되지 못한다.
			이유는 추상클래스와 같이 인터페이스 소속함수는 
			모두 내용이 없는 불완전한 추상 함수이기 때문이다.
			따라서 일반 클래스에게 상속을 해준다.
			
			상속해주는 방법 ]
				
				[접근지정자] class 클래스이름	implements 인터페이스이름 {
					추상함수 오버라이딩
				}
				
				참고 ]
					일반 클래스를 상속받는 것은 "상속" 이라고 표현하고
					인터페이스를 상속받는 것은 "구현" 이라고 표현한다.
					
			
			상속받은 클래스에서는 인터페이스 안에 있는 모든 추상 함수를 몸체를 만들어줘야 한다.
			그리고 필요한 기능을 개발자가 구현한다.
				==> 인터페이스 소속 함수의 접근지정자는 public 이다.
			
			상속받은 일반클래스를 new 시켜서 사용한다.
			==> 이 방법이 인터페이스 사용방법의 90% 차지...
			
		2. 약 10 % 정도는 
			추상클래스처럼
				반환값이 자기자신이면서 속성이 static인 함수를 이용해서 사용해야 한다.
				
			참고 ]
				추상함수에는 이런 함수가 존재하지만
				인터페이스에는 다른 클래스에 이런 함수가 존재한다.
				
참고 ]
	인터페이스는 다중 상속이 가능하다.
	
	형식 ]
		
		public class 클래스이름 implements 인터페이스1, 인터페이스2, ... {
		
		}
		
		주의 사항 ]
			이 경우는 상속해준 인터페이스 내의 모든 함수들을 
			오버라이드해서 몸체만들어줘야 한다.

참고 ]
	일반 상속과 인터페이스 구현을 같이 사용할 수 있다.
	
	형식 ]
		
		public class 클래스이름 extends 상속해줄클래스이름 implements 인터페이스1, 인터페이스2, ... {
		
		}
		
	주의  ]
		반드시 extends 가 먼저 와야 한다.
		
		
=======================================================================================================
참고 ]
	인터페이스도 다른 인터페이스를 상속 받아서 만들 수 있다.
	
	형식 ]
		
		public interface 인터페이스이름 extends 상속해줄인터페이스이름 {
			
		}
		
=======================================================================================================

참고 ]
	인터페이스 내부에도 일반함수가 올 수 있다.
	이 경우는 반드시 함수의 속성에 default 라고 명시해야 한다.
	
=======================================================================================================

내부 클래스(Inner Class)
==> 클래스 내부에 다시 만들어지는 클래스

종류 ]
	1. Top Level Inner Class
		==> 형식은 내부 클래스이지만 독립적으로 활동하는 클래스
		
		형식 ]
			
			static class 클래스이름 {
			}
			
		내부에 만들지는 클래스에 static 속성이 부여되면 탑레벨 내부클래스가 된다.
		
		참고 ]
			클래스이름
			일반클래스와 달리 내부클래스의 이름은
				"바깥클래스이름.내부클래스이름" 
			의 형식으로 접근해야 한다.
			
		참고 ]
			static 내부클래스 내에서만 static 멤버를 만들 수 있다.
	
	***
	2. 전역 Inner Class
		==> 일반 클래스를 내부 클래스로 만든 것.
			(이 클래스가 일반적으로 부르는 내부클래스에 해당한다. 90%)
			
			형식 ]
				class 클래스이름 {
				}
				
			특징 ]
				1. 바깥클래스의 모든 멤버는
					자동으로 자기것처럼 사용할 수 있다.
				2. 반드시 바깥클래스가 new 된 후에 안쪽 클래스를 생성할 수 있다.
					형식 ]
						바깥클래스주소.new 내부클래스이름();
						
				3. 바깥 클래스는 안쪽클래스 멤버를 사용할 수 없고
					사용하기 원하는 경우는 new 시켜서 주소를 통해서 접근해야 한다.
					
		주로 바깥클래스와 연관된 기능을 가진 클래스를 만들고 싶을 때 많이 사용한다.
					
	
	3. 지역 Inner Class
		==> 내부 클래스를 만드는 위치가 바깥 클래스의 함수 내부에서 만들어진다.
		
			class Test {
				int a;
				
				void abc(){
					class localInner {
						클래스 내용
					}
					
					new localInner();
				}
			}
			
		특징 ]
			1. 전역 Inner 클래스와 유사하게 바깥 클래스의 멤버는 사용할 수 있다.
			2. 이 클래스는 다른곳에서 new 시켜서 사용할 수 없다.
				오직 해당 함수 내에서만 new 시켜서 사용할 수 있다.
				
	*****
	4. 무명 Inner Class
	==> 이름이 없는 내부 클래스
	
		프로그램을 제작하다보면
		기능 수정을 위해서 오버라이드를 해야 하는 경우가 발생한다.
		(또는 반드시 재정의 해줘야만 하는 경우...)
		
		이때 원칙적인 규칙은 
		별도로 클래스를 정의해서 해당 클래스를 new 시켜서 사용하는 것이 원칙이지만
		
		내용이 간단한 경우는 
		그 간단한 내용때문에 상속받아서 오버라이드 작업을 하는 것이
		무척 번거롭다.
		
		결론적으로
		무명클래스란?
		이런 경우를 위해서 만들어진 클래스로
		클래스를 new 시키는 순간 만들어지는 인스턴스를 바로 사용하면 
		클래스의 이름이 별도로 필요없게 된다.
		
		따라서 사용자가 클래스이름을 만들지 않아도 된다. 라는 의미에서
		무명 내부 클래스라 부른다.
		
		형식 ]
			
			new 클래스이름 또는 인터페이스이름(){
			
			}
			
==========================================================================================================

가변인자
==> 함수를 정의 할 때
	그 함수가 가지고 있는 매개변수는 동일한 갯수, 형태, 순서를
	이용해서 함수를 호출해야 한다.
	
	만약
	데이터의 갯수가 정해지지 않는 경우는 ???
	==> 이런 경우 사용할 수 있는 매개변수 처리 방법이 가변인자이다.
	==> 데이터의 갯수와 상관없이
		여러 데이터를 모두 받을 수 있다.
		
	형식 ]
		
		반환값타입	함수이름(데이터타입 ... 변수이름){
		
		}
	

























































		