# day06


-------------------------------------------------------------------------------------------------------------
멤버(Member)
	- 클래스는 해당 클래스의 속성을 기억할 변수와
							가지는 기능을 만들어놓은 함수로 이루어져있다.
							
	- 따라서 클래스가 객체가 되면
		변수와 함수도 사용할 수 있게된다.
		
	- 이 때 이 변수와 함수를 멤버라 표현한다.
	
따라서
클래스가 가지는 변수와 함수를 사용하는 방법은
먼저 클래스를 객체로 만든후
사용해야 한다.
	
	형식 ]
		
		클래스이름	변수이름 = new 클래스이름();
		변수이름.변수;
		변수이름.함수();
		
-------------------------------------------------------------------------------------------------------------

함수의 오버로딩(Overloading : 함수의 중첩)
==> 원칙적으로 같은 클래스안에서는 함수의 이름은 모두 달라야 한다.
	같은 클래스 안에서 같은 이름의 함수가 존재하면 에러가 발생한다.
	
	이러다 보니 가독성에 문제가 발생한다.
	즉, 가독성이란?
	함수의 이름만 봐도 그 함수가 어떤 기능을 가지고 있는 함수인지를 알수 있어야 하는데...
	함수의 이름을 다르게 만들다 보면
	가독성에 문제가 발생할 수 있다.
	
	이런 불편함을 해결하기 위해서 도입된 문법이
	함수의 "오버로딩"이다.
	
	함수의 오버로딩이란?
	같은 클래스안에서 같은 이름의 함수를 만들 수 있다.
	단, 다음 조건은 반드시 지켜야 한다.
	
		오버로딩 조건
			0. 함수가 존재해야 한다.
			1. 함수의 이름이 같아야 한다.
			2. 매개변수리스트가 달라야한다.
				--> 변수이름은 상관없고
					갯수 또는 순서가 달라야한다.
			3. 반환값과는 전혀 상관없다.
			
			
	***
	오버로딩은
	함수의 매개변수의 갯수, 순서, 형태 중 하나이상이 달라야 한다.
	
-------------------------------------------------------------------------------------------------------------

생성자 함수(Constructor)
==> 클래스를 사용하기 객체로 만드는 new 시키는 순간 자동 실행되는 함수.

	즉, 클래스를 new 시킨다는 것은 
	오브젝트로 만들어서 실행한다는 의미이다.
	따라서 이때 실행한다는 개념은 결국 오브젝트(객체)를 만드는 순간
	뭔가를 실행한다는 개념이다.
	이것은 물건을 만들때 필요한 뭔가 조치를 한다는 개념이다.
	==> 
		결론적으로 실제로 실행 가능한 것으로 만들기 위한 함수
		
	클래스는 한가지 목적을 달성하기 위해서 만들어진 프로그램의 기본단위이다.
	이 안에는 그 목적을 달성하기 위해 변수, 함수로 구성된다.
	하지만 그 목적을 달성하기 위해서는 기본적으로 어떤 조치가 필요한 경우가 있다.
	
	예 ]
		String
			==> 문자열을 관리할 목적으로 만들어진 클래스이다.
				==> 문자열을 기억하고 잇어야 한다.
				
		FileOutputStream
			==> 파일에 내용을 기록하기 위한 목적으로 만들어진 클래스
				==> 파일을 사용할 수 있도록 열어놓아야 할 것이다.
				
		Socket
			==> 네트워크를 구성하기 위한 목적으로 만들어진 클래스
				==> 상대방과 접속은 이루어져야 할 것이다.
				
	프로그램은 프로그램 답게 뭔가를 처리 하기 위해서는 함수가 필요하다.
	위의 경우를 비춰보면 각각의 클래스는 오브젝트로 만들어지는 순간
	그 클래스 만의 최소한의 일을 할 필요가 있더라.
	
	바로 이런일을 하기 위해 만들어 놓은 함수를
	"생성자(Constructor)"라고 부른다.
	
	생성자 함수를 만드는 이유는
	만들고자 하는 클래스이 목적에 따라
	그 클래스가 해야할 가장 기본적인 일을 처리하기 위해서 만드는 것이다.
	
	생성자함수 만드는 방법
		
		규칙 ]
			1. 함수의 이름은 반드시 클래스이름과 동일해야 한다.
			2. 반환값은 절대로 가지면 안된다.
			3. 매개변수는 가질 수 있다.
			
	주의사항 ]
		
		생성자 함수를 만들지 않아도 사용할 수 있다.
		이때는 자바가상머신(JVM)이 기본 생성자를 만들어서 호출하게 된다.
		생성자 함수를 하나라도 정의 하게 되면
		이때는 자바가상머신이 기본생성자를 만들지 않는다.
		따라서 생성자를 정의할 때는 반드시 기본생성자(매개변수가 없는 생성자)도 같이 정의하는 것이 좋다.
		
	참고 ]
		생성자 함수도 오버로딩이 가능하다.
		==> 생성자 함수도 여러개로 정의할 수 있다.
		
	생성자 함수 이용방법 
		생성자 함수는 그 클래스를 어떻게 new 시킬지를 알려주는 함수이다.
		
		즉, 생성자 함수가 요구하는 매개변수가 무엇인지를 알면
		그 클래스를 객체로 만들 수 있다.
		
	참고 ]
		this()
		==> 생성자 함수는 원칙적으로 개발자가 직접 호출할 수 없다.
			
			현재 생성자를 실행하는 도중에 다른형태의 현재 클래스의 생성자를 
			강제로 호출하는 유일한 방법
		
			***
			규칙 ]
				1. 반드시 생성자 안에서만 사용할 수 있다.
					일반함수 내에서는 절대로 사용할 수 없다.
				2. 반드시 생성자 함수의 첫문장, 첫 명령으로 사용해야 한다.
					이전에 다른 문장이 있으면 에러가 발생한다.
					
------------------------------------------------------------------------------------------------------------
참고 ]
	this
		==> 현재 실행중인 객체 자기자신을 가리키는 예약어...
				
------------------------------------------------------------------------------------------------------------
접근지정자
	==> 그 내용을 누구(어디)까지 사용할 수 있는지를 지정하는 예약어
		즉, 우리가 클래스를 만든다고 해서
		그 클래스(내용) 을 모든 사람에게 공개해야 되는 것은 아니다.
		클래스를 제작하는 사람이 사용범위를 지정할 수 있도록 한 것이다.
		
		예 ]
			class는 어디까지 이 클래스를 사용할 수 있도록 할까??
		예 ]
			함수는 어디까지 이 함수를 호출할 수 있도록 할 까??
			
	종류 ]
		1. public
			: 모든 곳에서 사용할 수 있다.
		
		2. protected
			: 상속 받은 하위 클래스 + 같은 패키지 소속에서만 사용할 수 있다.
		
		3. 생략
			: 같은 패키지 안에서는 사용할 수 있다.
		
		4. private
			: 같은 클래스 안에서만 사용할 수 있다.
			
			
	참고 ]
		클래스에는 public, 생략만 사용가능하다.
		
***
은닉화
	프로그램에 있어서 가장 중요한 요소는 데이터이다.
	즉, 변수가 프로그램의 핵심적인 요소가 된다는 것이다.
	무결성 데이터를 유지할 수 있는 것이 가장 중요한 개념이다.
	
	은닉화란?
		이처럼 중요한 요소인 변수를 사용자가 함부로 변경하지 못하도록
		방지하는 기술을 이야기한다.
		(결점이 있는 데이터가 발생하지 않도록 하는 것)
		
		방법
			1. 데이터가 기억될 변수는 private 으로 처리한다.
				(이렇게 처리해 놓으면 다른 클래스에서는 데이터 입력, 열람도 불가능해진다.)
			2. 이 변수의 값을 변경하거나 읽을 수 있는 기능을 만들어 준다.
				(함수를 제작해준다. Getters & Setters...)
		
=======================================================================================================

this
==> 교과서적인 의미로 
	현재 실행중인 오브젝트의 주소를 기억하는 약속된 변수
	
	이것은 JVM이 클래스를 처리하기 위해서 JVM이 사용하는 변수.
	따라서 개발자는 거의 이변수는 사용하지 않는다.
	
	규칙 ]
		1. 모든 멤버는 사용할 때 반드시 앞에 주소가 있어야 한다.
			멤버는 클래스 안에 만들어진 변수나 함수를 이야기 한다.
			
			따라서 new 를 시킨 후 그 주소를 기억해 놓았다가
			그 주소를 이용해서 사용하는 것이다.
			
		2. 만약 주소가 없으면 JVM이 자동적으로 this를 붙여준다.
		3. 멤버함수를 호출할 때는 무조건 주소값을 함수에게 알려주도록 약속했고
			함수는 this 변수를 준비한 후
			함수를 호출할 때 알려준 주소를 기억하게 된다.
			
	참고 ]
		딱 한번 this를 개발자가 사용해야 하는 경우가 있다.
		
		가끔은 지역변수와 멤버 변수가 이름이 동일하게 만들어지는 경우가 발생한다.
		이때 따로 지정하지 않으면 변수는 지역변수를 사용하게 된다.
		따라서 멤버 변수에 데이터가 기억되지 않을 수 있다.
		이때 
			굳이 이 변수가 멤버 변수임을
			명확하게 밝혀주고 싶은 경우가 생기면
			이때 강제로 this라고 붙여준다.

======================================================================================================
클래스 만드는 형식 ]
	
	[접근지정자]	[속성]	class	클래스이름 {}
	
	[접근지정자]	[속성]	반환값타입	함수이름(매개변수리스트){}
	
	[접근지정자]	[속성]	데이터타입	변수이름;
	
속성 ]
	
	static
		==> static 영역에 생기는 함수나 변수들에게 붙여주는 속성
		
		참고 ]
			클래스, 함수, 변수를 만들때 속성을 지정할 수 있다.
			
		특징 ]
			1. 프로그램이 실행되기 위해서 JVM이 ㅣ로딩하는 순간 저절로 생기는 영역
				사용자가 별도로 만들어달라고 요구하지 않아도 자동적으로 생기는 영역
				
			2. 한번 만들어진 변수나 함수는 두번 생기지 않는다.
			
			
	static 변수
		==> static 영역에 만들어지는 변수
			형식 ]
				[접근지정자]	static 데이터타입 변수이름;
				
			특징 ]
				1. 여러 오브젝트(객체)가 공동으로 사용하는 변수가 된다.
					<== 오브젝트를 100개를 만들어도
						static 변수는 오직 한개만 static 영역에 생기므로...
						
						따라서 한 객체에서 데이터를 바꾸면
						다른 객체에서도 바뀐데이터를 사용해야 한다.
						
				2. new 시키지 않아도 사용할 수 있는 변수
					왜??
						이미 메모리에 올려져 있으니까...
						
			사용방법 ]
				
				클래스이름.변수이름;			
			
				
	static 함수
		==> static 영역에 만들어지는 함수
			따라서 객체가 만들어지지 않아도 사용할 수 있는 함수
			
		사용방법 ]
			클래스이름.함수이름();
			
		***
		이 함수는 this를 사용할 수 없는 함수이다.
		
		결론 ]
			static 함수 안에서는 static 멤버만 사용할 수 있다.
			일반 함수 안에서는 static 멤버와 일반멤버도 사용할 수 있다.
			
=======================================================================================================

멤버 변수의 초기화
==> 멤버 변수는 heap 영역에 생기므로 자동 초기화가 된다.
	하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
	
	1. 명시적 초기화
		==> 변수를 선언하면서 값을 입력하는 것.
			가장 먼저 실행된다.
			
			예 ]
				class Test {
					int no = 10; // 명시적 초기화
				}
				
	2. 초기화 블럭을 이용한 초기화
		==> 이것은 인스턴스 변수에 대해서만 가능한 것으로
			두번째로 실행되는 방법
			
			형식 ]
				
				{
					이 안에 데이터를 변수에 입력
				}
				
				
			예 ]
				class Test {
					int no ;
					 
					{
						no = 100;	// 초기화 블럭을 이용한 초기화
					}
				}
		
		
	3. static 블럭을 이용한 초기화
		==> 2번과 비슷한데 static 변수에 한해서만 적용되는 방법
			두번째로 실행되는 방법
			
			형식 ]
				static {
					변수에 데이터 입력
				}
				
			예 ]
				class Test {
					static int no;
					
					static {
						no = 1000; // static 블럭을 이용한 초기화
					}
				}
			
	4. 생성자 함수를 이용한 초기화
		==> 제일 마지막에 실행되는 방법
		
		예 ]
			class Test {
				int no;
				
				public Test(int no){
					this.no = no;
				}
			}
		
======================================================================================================
	
	상속
	==> 이미 만들어진 클래스의 기능을 그대로 물려받아서
		(변수와 함수의 기능을 그래도 복사 받아서)
		새로운 클래스를 만드는 방법
		
		이 개념이 나타나게 된 이유??
			<== 소프트웨어의 개발 속도를 빠르게 하기 위한 방법의 한가지....
			
		객체 지향 언어는 부품 단위(클래스)로 프로그램을 만든 후
		그 부품들을 조립해서 원하는 결과를 얻어내는 언어이다.
		
		상속은 자신이 만들고자하는 부품과 가장 유사한 부품을 가지고 와서
		일단 그 기능을 복사한 후
			1. 없는 기능만 덧붙이고
			2. 있는 기능중 바꿀 내용은 수정하고...
			
		형식 ]
			class 클래스이름	extends	상속받을클래스이름 {
				함수를 수정 또는 추가작업
			}
			
		참고 ]
			자바는 단일 상속만 가능하다.
			
			예 ]
				
				class Test extends String, Integer { // 절대로 안된다. 단일상속만 가능하다.
				}
				
	용어 정리 ]
		
		상속을 해준 클래스	- Super Class, 상위클래스(, 부모클래스, 조상클래스)
		상속을 받은 클래스	- Sub Class, 하위클래스(, 자식클래스, 자손클래스)
		
=====================================================================================================
	상속관계에 있는 경우 생성자의 역할
		
		결론적으로
			하위 클래스가 생성되는 순간
			상위 클래스가 자동 생성된다.
			==> 생성되는 순간 생성자 함수가 호출된다.
				결국 하위클래스를 생성하면
				상위클래스의 생성자 함수도 실행된다.
				
		결국 상위 클래스의 생성자 함수는 자동 호출되는 개념이다.
		이때 호출되는 생성자함수는 무조건 기본 생성자만 이용하게 된다.
		
		***
		참고 ]
			super	: 실행중인 객체의 상위 클래스를 기억하는 변수
						this가 실행중인 객체 자기자신을 기억하는 예약되 변수이듯이
						super역시 예약된 변수중 하나이다.
						자신의 상위 클래스의 주소가 기억되는 변수
						
				사용목적 ]
					반드시 소속을 밝혀야할 필요가 있는 경우 사용한다.
					
			
			super()	: 상위 클래스의 특별한 생성자 함수를 호출할 수 있는 유일한 방법이다.
						this()와 같이 생성자의 첫줄 첫문자으로만 사용할 수 있다.
						
			public class Test extends Example {
				
				public Test(){
				//	super();// 상위클래스의 생성자를 호출하지 않으면 이 함수가 호출되는 것이다.
					super(데이터);	// 상위 클래스의 기본생성자가 아닌 생성자를 호출하는 방법
				}
			}
			
=======================================================================================================

***
오버라이딩( Overriding : 함수의 재정의 )
==> 상속관계에 있는 하위클래스에서
	상위클래스가 가진 함수의 기능을 수정하는 행위
	
	방법 ]
		0. 상위클래스가 해당함수를 가지고 있어야 한다.
		1. 상위클래스가 가진 함수의 원형과 동일한 원형으로 만들어야 한다.
			
			참고 ]
				함수의 원형(Prototype) :
							반환값 + 함수이름 + 매개변수리스트
							
		2. 접근지정자는 같거나 넓은 방향으로...
		3. 예외처리는 같거나 좁은 방향으로...
		
	이렇게 오버라이딩을 하게 되면
	내부적으로 상위클래스가 가진 함수가 숨겨지고 재정의한 함수가 실행된다.

=====================================================================================================
	**********
	다형성
	==> 하나의 변수를 이용해서 여러형태의 클래스를 사용하도록 하는 기법
		
		주소의 형변환(Casting)
		==> 원칙적으로 주소는 다른 형태로 형변환이 불가능하다.
			즉, 주소는 heap 형태에 따라 주소가 결정되므로
			Heap 형태가 다르면 주소를 기억를 기억할 수 없다.
			
			예 ]
				int[] a = new int[5];	--> O
				
				Test t = new Ex01();	--> X
				
			***
			오직 한가지 경우에 한해서 주소의 형변환이 가능하다.
			상속 관계에 있는 클래스끼리는 형변환이 가능하다.
			
			이런 관계를 
				is	a
			관계라고 한다.
			
			참고 ]
				has a : 멤버로 가지고 있는지를 묻는 것.
				
				
				
			자동 형변환 ]
				하위클래스의 주소가 상위클래스의 변수에 기억되는 것은
				자동적으로 형 변환을 해준다.
				
				예 ]
					망둥어는 물고기다.
					
			강제 형변환 ]
				상위 클래스의 주소가 하위 클래스 변수에 기억되는 것은
				원칙적으로 불가능하며
				강제로 형변환 해줄 수는 있다.
				
			class Grand {
				void abc(){
					System.out.println("여기는 Grand");
				}
			}
			
			class Father extends Grand {
				void abc(){
					System.out.println("여기는 아부지 클래스");
				}
				
				void xyz(){
					System.out.println("한글 사랑");
				}
			}
			
			class Son extends Father {
				void abc(){
					System.out.println("여기는 Son 클래스");
				}
			}
				
			Son s = new Son();	---> O
			Father f = s;
			
			Father f1 = new Father();
			Son s1 = f1; ---> X
			Son s1 = (Son) f1;	---> O : 강제 형변환
			
			다형성이란?
			주소의 형변환 이론을 기반으로하여
			상위 클래스의 주소를 이용해서 하위 클래스를 이용할 수 있으며
			상위 클래스의 주소를 이용하면 여러 하위 클래스를 다룰 수 있다.
			
	참고 ]
		변수는 래퍼런스쪽을 따르고
		함수는 인스턴스쪽을 따른다.
			
