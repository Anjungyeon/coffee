# day09

Collection
==> 많은 양의 데이터를 손쉽게 보관할 수 있는 클래스들의 집합

	배열을 이용해도 많은 양의 데이터를 보관할 수 있지만...
	단점 ]
		크기를 변경할 수 없다.
		==> 한번 데이터의 양(갯수)을 정하면 
			그 양보다 많은 데이터는 보관할 수 없다.
		데이터의 입출력에 제약이 있다.
		(반드시 위치를 알아야 데이터 입출력이 가능하다.)
		
	
	종류 ]
		
		1. List 계열
			특징 
				1) 입력한 순서를 보장한다.
					(처리속도가 느리다.)
				2) 중복 데이터도 중복해서 저장할 수 있다.
			
		2. Set 계열
			특징
				1) 입력한 순서를 보장하지 않는다.
					(나름의 규칙에 의해서 데이터를 정렬해서 보관한다.
						따라서 처리속도가 빠르다.)
				2) 중복 데이터가 다시 저장되면 먼저 데이터를 삭제한 후
					저장한다. 
					==> 중복데이터는 한번만 저장한다.
		
		3. Map 계열
			특징
				1) 데이터를 그 데이터를 구분할 키값과 한쌍을 만들어서 저장한다.
				2) 입력순서는 보장하지 않는다.
				3) 같은 키값이 입력되면 먼저 데이터는 삭제한다.
					(즉, 데이터가 같아도 되지만 키값은 같으면 안된다.)
					
	참고 ]
		List와 Set 계열은 상위클래스가 같지만
		Map 계열은 다르다.
		따라서 List 계열과 Set계열은 다형성 처리가 가능하지만(서로 형변환이 가능..)
		Map은 독립적으로 변환이 불가능하다.
		
===========================================================================================================================

List 계열
	
	1. Vector
		==> 내부적으로 배열 형태로 만들어서 데이터를 보관하는 컬렉션의 한 종류이다.
			
			장점 ]
				입력속도와 검색 속도가 빠르다.
			단점 ]
				중간에 데이터를 삽입하거나 데이터를 삭제하는 속도는 느리다.
			결론 ]
				데이터의 변화가 거의 없는 프로그램에서 많이 사용한다.
				
			생성방법 ]
				
				1. Vector()
					==> 배열의 크기를 10으로 정한 상태로 벡터를 만들어준다.
						데이터가 크기를 초과하는 순간 *2 의 크기를 갖는다.
						
				2. Vector(Collection c)
					==> 다른 컬렉션의 데이터를 복사해서 벡터를 만들어준다.
					
				3. Vector(int initialCapacity)
					==> 사용자가 직접 배열의 크기를 정해서 벡터를 만든다.
					
				4. Vector(int initialCapacity, int capacityIncrement)
					==> 3번 + 데이터의 양이 초과될 경우 증가하는 크기를 지정해서 벡터를 만든다.
					
					참고 ]
						컬렉션은 데이터의 양에 관계없이 항상 데이터를 입력 받을 수 있다.
						이때 데이터를 입력 받을 공간을 확보해야 하는데
						공간 확보 규칙은 기본값이 
							"기존공간 * 2"
						의 형태로 만들어진다.
						
			주요함수 ]
				1. 데이터를 입력하는 함수
					add(Object e)
					add(int index, Object element)
					addAll(Collection c)
					add(int index, Collection c)
					addElement(Object obj)
					insertElementAt(Object obj, int index)
					
				2. 데이터 수정함수
					set(int index, Object element)
					setElementAt(Object element, int index)
					
				3. 데이터 꺼내는 함수
					get(int index)
					elementAt(int index)
					firstElement()
					lastElement()
					elements()
		
	2. ArrayList
		==> Vector의 신버젼 으로
			역시 내부적으로 배열 형태로 데이터를 관리하기 때문에
			Vector의 특징을 그대로 가지고 있다.
			하지만 스레드에서 동기화 처리를 자동으로 해주므로
			요사이 Vector 보다는 ArrayList를 선호하는 경향이 있다.
			
			사용방법 역시 벡터와 비슷하다.
			
		참고 ]
			list 계열의 주소를 출력하면
			마치 데이터가 출력된 것처럼 보이지만
			이것은 toString() 를 오버라이드 해 놓아서 내용이 출력만 될 뿐이다.
			절대로 데이터를 사용하는 개념은 아니다.
			
	3. LinkedList
		==> 내부적으로 이중 연결 리스트 방식으로 데이터를 보관하는 방식의 컬렉션의 일종이다.
			
			장점 ]
				데이터를 중간에 끼워넣는 작업, 삭제하는 작업 속도는 빠르다.
			단점 ]
				데이터를 누적시키는 작업은 속도가 느리다.
				
참고 ]
	Iterator
	==> 컬렉션은 많은 클래스의 집합이고 그 형태도 다르다.
		그런데 이들은 서로 혼용될 수 있다.
		그 안에 데이터를 꺼내는 방식은 약간씩 다르다.
		리스트에서 데이터를 꺼내는 방식과 Set에서 데이터를 꺼내는 방식이 다르다.
		이때 꺼내는 소스를 다르게 만들어야 한다는 말이된다.
		
		그래서 데이터를 꺼내기 위해서만 사용하는 클래스를 따로 만들어 놓았다.
		그 클래스가 Iterator 클래스이다.
		따라서 List 계열이던 Set 계열이던지 Iterator로 변환만 시켜주면
		같은 방식으로 데이터를 꺼낼 수 있게 된다.
		꺼내는 소스를 통일해서 사용할 수 있게 된다.
		
		특징 ]
			StringTokenizer와 유사하게
			순차적으로만 꺼낼 수 있고
			한번꺼낸 데이터는 자동 삭제된다.
			
==========================================================================================================================
Collections
==> 이것은 이름은 컬렉션이지만 컬렉션은 아니고
	컬렉션을 이용할 때 필요한 부가적인 기능을 제공하는 
	유틸리티적인 클래스...
	
	주의 ]
		List를 달라고 하면 
			List는 인터페이스이기 때문에 new 시켜서 객체를 만들수 없고
			이때 List 계열을 입력해주면 된다.
			
		Collection을 달라고 하면
			List 계열이나 Set 계열을 주면 된다.
			
		Map을 달라고 하면 Map 계열을 주면 된다.
		
	참고 ]
		일반적인 정렬은 오름차순으로 정렬을 하게 된다.
		만약 정렬 방식을 변경하고자 하면
		sort(List list, Comparator c) 를 사용해야 한다.
		
==========================================================================================================================
Set 계열
	
	입력한 순서대로 보관하지 않고
	나름의 규칙에 의해서 내부적으로 정렬해서 보관하는 컬렉션
	중복된 데이터는 한번만 저장한다.
	같은 데이터가 입력이 되면
	먼저 데이터는 삭제하고 나중 데이터로 교체해서 보관한다.
	
	종류 ]
		
		1. HashSet
			==> Set 계열은 데이터를 기억할 때
				자신만의 규칙을 가지고 정렬해서 데이터를 기억하는데
				HashSet은 정렬 기준이 HashCode를 사용한다.
				따라서 우리가 사용하던 일반적인 정렬방식으로 
				정렬이 안될 수 도 있다.
				
			참고 ]
				Set 계열은 데이터를 꺼내는 기능이 없다.
				==> 왜?
					개발자가 데이터가 기억된 주소를 모르기 때문에 ....
					따라서 특정위치의 데이터를 꺼낼 수 있는 방법이 없다.
					그래서 Iterator로 변환해서 
					순서대로 꺼내서 사용하도록 하고 있다.
					
		
		2. TreeSet
			==> 내부적으로 Tree Sort 라는 알고리즘을 이용해서 
				데이터를 보관하는 기능을 가진 컬렉션의 일종
				특징 ]
					우리가 알고있는 정렬방식을 이용한다.
					
			생성방법 ]
				TreeSet(Comparator comparator)
				==> 정렬방식을 변경해서 TreeSet을 만든다.
				
				TreeSet(SortedSet<E> s)
				==> TreeSet을 이용해서 다시 TreeSet을 만든다.

==========================================================================================================================

Map
==> 하나의 데이터를 그 데이터를 구분할 키값과 한쌍으로 만들어서 기억하는 컬렉션의 일종이다.
	그리고 사용할 경우는 키값을 사용해서 데이터를 꺼낼 수 있도로 해놓았다.
	
	Map 계열은 많은 양의 데이터를 보관하는 용도보다는 
	데이터를 손쉽게 구분하여 사용할 목적으로 사용한다.
	
	
	Hashtable / HashMap
		Hashtable 이 구버젼이고
		HashMap이 이후에 만들어진 것이다.
		
		내부적으로 키값을 해쉬테이블을 이용해서 정렬해서 보관한다.
		
		주요함수 ]
			
			put(Object key, Object value)
			==> 데이터를 입력하는 함수
			get(Object key)
			==> 필요한 데이터를 꺼내는 함수
			
		참고함수 ]
			values()
			==> 데이터만 꺼내서 사용할 수 있는 함수
			keys()
			==> 키값들만 꺼내주는 함수
		
		참고 ]
			keys()로 꺼낸 데이터는 Enumeration으로 반환해준다.
			==> Enumeration은 Iterator의 구버젼이다.
				데이터를 순차적으로 꺼낼 수 있는 타입이다.
				
		참고 ]
			HashMap에서는 키값만 꺼내는 함수가 keySet() 이라는 함수가 추가되었다.
			
		참고 ]
			entrySet()
			==> Map은 반드시 키값을 알아야 데이터를 꺼낼 수 있다.
				Set은 데이터가 오직 한개씩 저장된다.
				어떻게 해서든지 키값과 데이터를 하나로 묶어야만 Set에 입력이 된다.
				
				이것을 해결하기 위해서 VO 클래스를 만들어서 제공해주고 있다.
				그 클래스가 
					Map.Entry
				라는 클래스이다.
				==> 
					이 클래스 안에는 key와 value 변수를 은닉화 시켜놨고
					이 변수를 사용할 수 있는 함수를 제공하고 있다.
					
==========================================================================================================================

TreeMap
==> 
	TreeSet과 마찬가지로 내부에서 정렬하면서 데이터를 기억하는 Map이다.
	이때 정렬기준은 키값을 이용해서 정렬하게 된다.
	따라서 키값이 정렬이 되지 않는 클래스는 입력이 안되고
	필요하다면 정렬 방식을 정해서 사용해야 한다.
	
참고 ]
	컬렉션 안에는 다시 컬렉션을 입력할 수 있다.
	왜?
		컬렉션에 입력될 수 있는 데이터는 Object 타입이고
		자바의 모든 데이터는 Object 타입으로 형변환이 가능하다.
		
***
컬렉션에 기억되는 데이터 타입을 별도로 지정하지 않으면
Object 타입으로 자동 형변환이 되서 기억된다.
따라서 꺼내서 연산을 할 경우는 반드시 원래 타입으로 강제 형변환을 해서 사용해야 한다.











	
		 